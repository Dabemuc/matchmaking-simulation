{
  "annotations": {
    "list": [
      {
        "builtIn": 1,
        "datasource": { "type": "grafana", "uid": "-- Grafana --" },
        "enable": true,
        "hide": true,
        "name": "Annotations & Alerts",
        "type": "dashboard"
      }
    ]
  },
  "editable": true,
  "fiscalYearStartMonth": 0,
  "graphTooltip": 1,
  "links": [],
  "panels": [
    {
      "title": "Simulation Vitals",
      "type": "row",
      "gridPos": { "h": 1, "w": 24, "x": 0, "y": 0 }
    },
    {
      "title": "Goroutines & Threads",
      "type": "timeseries",
      "interval": "0.25s",
      "description": "Displays the number of active Go routines and OS-level threads. A steady upward trend in Goroutines indicates a leak. A spike in OS Threads suggests the harness is hitting blocking I/O (system calls/network) rather than Go-level concurrency limits.",
      "gridPos": { "h": 7, "w": 12, "x": 0, "y": 1 },
      "options": { "tooltip": { "mode": "multi", "sort": "none" } },
      "targets": [
        { "expr": "go_goroutines", "legendFormat": "Goroutines" },
        { "expr": "go_threads", "legendFormat": "OS Threads" }
      ],
      "fieldConfig": { "defaults": { "min": 0 } }
    },
    {
      "title": "Active Players & Concurrency",
      "type": "timeseries",
      "interval": "0.25s",
      "description": "Compares total alive players vs. players currently executing a scenario. If 'Busy' stays equal to 'Active', your player pool is 100% saturated and you cannot execute more scenarios without increasing the player count.",
      "gridPos": { "h": 7, "w": 12, "x": 12, "y": 1 },
      "options": { "tooltip": { "mode": "multi", "sort": "none" } },
      "targets": [
        { "expr": "harness_players_active", "legendFormat": "Active Players" },
        {
          "expr": "sum(harness_scenarios_in_flight)",
          "legendFormat": "Busy Players (In-Flight)"
        }
      ],
      "fieldConfig": { "defaults": { "min": 0 } }
    },
    {
      "title": "CPU Usage",
      "type": "timeseries",
      "interval": "0.25s",
      "description": "Historical CPU usage relative to the GOMAXPROCS limit. If the line crosses the Hard Limit, the Go runtime is fully saturated.",
      "gridPos": { "h": 7, "w": 12, "x": 0, "y": 2 },
      "options": {
        "tooltip": { "mode": "multi", "sort": "none" }
      },
      "targets": [
        {
          "expr": "rate(process_cpu_seconds_total[1m]) / scalar(go_sched_gomaxprocs_threads)",
          "legendFormat": "Actual Usage (Ratio)"
        },
        {
          "expr": "vector(1)",
          "legendFormat": "Hard Limit (${max_procs} Cores)"
        }
      ],
      "fieldConfig": {
        "defaults": {
          "unit": "percentunit",
          "min": 0,
          "max": 1.2,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              { "color": "green", "value": 0 },
              { "color": "orange", "value": 0.8 },
              { "color": "red", "value": 1.0 }
            ]
          }
        },
        "overrides": [
          {
            "matcher": {
              "id": "byName",
              "options": "Hard Limit (${max_procs} Cores)"
            },
            "properties": [
              {
                "id": "color",
                "value": { "fixedColor": "red", "mode": "fixed" }
              },
              {
                "id": "custom.lineStyle",
                "value": { "dash": [5, 5], "fill": "solid" }
              }
            ]
          }
        ]
      }
    },
    {
      "title": "Memory",
      "type": "timeseries",
      "interval": "0.25s",
      "description": "Compares Heap Alloc (Go managed) vs Resident Set Size (OS managed). A widening gap suggests memory fragmentation or non-heap overhead.",
      "gridPos": { "h": 7, "w": 12, "x": 12, "y": 2 },
      "options": { "tooltip": { "mode": "multi", "sort": "none" } },
      "targets": [
        {
          "expr": "go_memstats_heap_alloc_bytes",
          "legendFormat": "Heap Alloc"
        },
        { "expr": "process_resident_memory_bytes", "legendFormat": "Total RSS" }
      ],
      "fieldConfig": { "defaults": { "unit": "bytes", "min": 0 } }
    },
    {
      "title": "Bottleneck Analysis",
      "type": "row",
      "gridPos": { "h": 1, "w": 24, "x": 0, "y": 8 }
    },
    {
      "title": "Player Wait Time (Pool Starvation)",
      "type": "timeseries",
      "interval": "0.25s",
      "description": "The time a scenario spends in the queue waiting for an idle player. Any value above 0ms indicates 'Starvation'. High wait times mean your Compositor is requesting work faster than your player pool can process it.",
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 9 },
      "options": { "tooltip": { "mode": "multi", "sort": "none" } },
      "targets": [
        {
          "expr": "histogram_quantile(0.99, rate(harness_pool_execute_wait_duration_seconds_bucket[1m]))",
          "legendFormat": "p99 Wait Time"
        },
        {
          "expr": "histogram_quantile(0.50, rate(harness_pool_execute_wait_duration_seconds_bucket[1m]))",
          "legendFormat": "p50 Wait Time"
        }
      ],
      "fieldConfig": { "defaults": { "unit": "s", "min": 0 } }
    },
    {
      "title": "Compositor Health (Tick Lag)",
      "type": "timeseries",
      "interval": "0.25s",
      "description": "Measures the delay between when a simulation 'tick' was supposed to happen and when it actually happened. High lag means the Go runtime is struggling (GC pauses or CPU exhaustion), making the simulation jittery.",
      "gridPos": { "h": 8, "w": 12, "x": 12, "y": 9 },
      "options": { "tooltip": { "mode": "multi", "sort": "none" } },
      "targets": [
        {
          "expr": "harness_compositor_tick_lag_seconds",
          "legendFormat": "Tick Lag: {{scenario}}"
        }
      ],
      "fieldConfig": { "defaults": { "unit": "s", "min": 0 } }
    },
    {
      "title": "Scenario Performance",
      "type": "row",
      "gridPos": { "h": 1, "w": 24, "x": 0, "y": 17 }
    },
    {
      "title": "Throughput by Status",
      "type": "timeseries",
      "interval": "0.25s",
      "description": "The rate of completed scenarios per second. 'Success' is your happy path. 'Failure' usually indicates application errors (500s). 'Cancelled' shows players logging out or context timeouts during the simulation.",
      "gridPos": { "h": 8, "w": 12, "x": 0, "y": 18 },
      "options": { "tooltip": { "mode": "multi", "sort": "none" } },
      "targets": [
        {
          "expr": "rate(harness_scenario_completed_total{status=\"success\"}[10s])",
          "legendFormat": "Success: {{scenario}}"
        },
        {
          "expr": "rate(harness_scenario_completed_total{status=\"failure\"}[10s])",
          "legendFormat": "Failure: {{scenario}}"
        }
      ],
      "fieldConfig": {
        "defaults": { "min": 0, "custom": { "stacking": { "mode": "normal" } } }
      }
    },
    {
      "title": "Execution Latency (p95)",
      "type": "timeseries",
      "interval": "0.25s",
      "description": "The time taken to execute a scenario from start to finish (95th percentile). If this climbs while 'Wait Time' is low, the target system (server under test) is slowing down.",
      "gridPos": { "h": 8, "w": 12, "x": 12, "y": 18 },
      "options": { "tooltip": { "mode": "multi", "sort": "none" } },
      "targets": [
        {
          "expr": "histogram_quantile(0.95, rate(harness_scenario_duration_seconds_bucket[1m]))",
          "legendFormat": "p95: {{scenario}}"
        }
      ],
      "fieldConfig": { "defaults": { "unit": "s", "min": 0 } }
    },
    {
      "title": "Login & Ramp-up Metrics",
      "type": "row",
      "gridPos": { "h": 1, "w": 24, "x": 0, "y": 26 }
    },
    {
      "title": "Login Success Rate",
      "type": "timeseries",
      "interval": "0.25s",
      "description": "Tracks how many players are successfully logging in per second. Failures here indicate that your authentication service or connection pool is failing before the load test even truly begins.",
      "gridPos": { "h": 7, "w": 12, "x": 0, "y": 27 },
      "options": { "tooltip": { "mode": "multi", "sort": "none" } },
      "targets": [
        {
          "expr": "rate(harness_player_login_total{status=\"success\"}[1m])",
          "legendFormat": "Success"
        },
        {
          "expr": "rate(harness_player_login_total{status=\"failure\"}[1m])",
          "legendFormat": "Failure"
        }
      ],
      "fieldConfig": { "defaults": { "min": 0 } }
    },
    {
      "title": "Login Duration (p95)",
      "type": "timeseries",
      "interval": "0.25s",
      "description": "Measures how long it takes for the harness to initialize a new player. High values here during a ramp-up phase suggest that the harness is struggling to open new connections or the auth server is bottlenecked.",
      "gridPos": { "h": 7, "w": 12, "x": 12, "y": 27 },
      "options": { "tooltip": { "mode": "multi", "sort": "none" } },
      "targets": [
        {
          "expr": "histogram_quantile(0.95, rate(harness_player_login_duration_seconds_bucket[1m]))",
          "legendFormat": "p95 Login Time"
        }
      ],
      "fieldConfig": { "defaults": { "unit": "s", "min": 0 } }
    }
  ],
  "refresh": "5s",
  "schemaVersion": 39,
  "templating": {
    "list": [
      {
        "datasource": {
          "type": "prometheus",
          "uid": "PBFA97CFB590B2093"
        },
        "definition": "query_result(go_sched_gomaxprocs_threads)",
        "hide": 2,
        "name": "max_procs",
        "options": [],
        "query": {
          "qryType": 3,
          "query": "query_result(go_sched_gomaxprocs_threads)",
          "refId": "PrometheusVariableQueryEditor-VariableQuery"
        },
        "refresh": 1,
        "regex": "/\\} (\\d+)/",
        "type": "query"
      }
    ]
  },
  "time": {
    "from": "now-5m",
    "to": "now"
  },
  "timezone": "browser",
  "title": "Harness Overview V2"
}
